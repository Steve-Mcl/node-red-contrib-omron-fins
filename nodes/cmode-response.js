module.exports = function (RED) {
    // eslint-disable-next-line no-debugger
    // debugger
    const C_MODE = require("../lib/_cmode.js");
    const cmodeCache = {
        CSJP: new C_MODE.CModeHelper("CSJP"),
        CV: new C_MODE.CModeHelper("CV"),
        Calpha: new C_MODE.CModeHelper("Calpha"),
    }
    cmodeCache.CS = cmodeCache.CSJP;
    cmodeCache.CJ = cmodeCache.CSJP;
    cmodeCache.CP = cmodeCache.CSJP;
    function OmronCModeResponse(config) {
        RED.nodes.createNode(this, config);
        this.wordNumber = config.wordNumber;
        const node = this;

        node.on('input', function (msg) {
            try {
                const response = (msg.payload ? msg.payload.toString() : '').trim()
                msg.cModeResponse = {timestamp: Date.now(), response}

                const startMark = response.slice(0,1)
                const endMark = response.slice(-1)
                const startMarkOK = startMark === "@";
                const endMarkOK = endMark === "*";//TODO: Support frames
                const hostNumber = response.substr(1,2);
                const headerCode = response.substr(3,2);
                let endCode = response.substr(5, 2);
                let dataStart = 7;

                msg.cModeResponse.startMark = startMark
                msg.cModeResponse.endMark = endMark
                msg.cModeResponse.hostNumber = hostNumber
                msg.cModeResponse.headerCode = headerCode
                msg.cModeResponse.endCode = endCode

                if(!startMarkOK) {
                    throw new Error("Invalid C-Mode Response. Expected a string beginning with @")
                }
                if(!endMarkOK) {
                    throw new Error("Invalid C-Mode Response. Expected a string ending with *")
                }
                if (!msg.cModeCommand || typeof msg.cModeCommand != "object" || !msg.cModeCommand.plcSeries) {
                    throw new Error("Invalid msg. Expected msg to contain an object named cModeCommand generated by a c-mode command node")
                }
                /** @type {C_MODE.CModeHelper} */
                const cmode = cmodeCache[msg.cModeCommand.plcSeries];
                if(!cmode) {
                    throw new Error("Invalid msg. Expected msg.cModeCommand.plcSeries to contain a valid PLC Series of 'CSJP', 'CV' or 'Calpha'")
                }
                if(headerCode === 'TS') {
                    if(response === (msg.request_payload || '').trim()) {
                        endCode = '00'
                        msg.cModeResponse.endCode = endCode
                        dataStart -= 2
                    }
                }
                if (endCode !== '00') {
                    const ec = cmode.parseEndCode(endCode);
                    throw new Error(ec);
                }

                //TODO: move the parsing into C_MODE
                const totalLength = response.length;
                const dataLength = totalLength - dataStart - 3 /* 3 = 2 for CRC and 1 for asterix */;
                
                const data = response.substr(dataStart, dataLength);
                const CRC = parseInt(response.substr(dataStart + dataLength, 2), 16)
                const CRCcalc = C_MODE.CModeHelper.calculateFCS(response.slice(0, -3))
                if(CRC !== CRCcalc) {
                    throw new Error(`Invalid frame check sequence. Received CRC ${CRC.toString(16)}, expected ${CRCcalc.toString(16)}`)
                }
                if(msg.cModeCommand.hostNumber != hostNumber) {
                    throw new Error(`Unexpected host number. Received ${hostNumber}, expected ${msg.cModeCommand.hostNumber}`)
                }
                if(msg.cModeCommand.headerCode != headerCode) {
                    throw new Error(`Unexpected header code. Received ${headerCode}, expected ${msg.cModeCommand.headerCode}`)
                }
                msg.cModeResponse.data = data
                msg.cModeResponse.CRC = CRC
                msg.cModeResponse.CRCCalc = CRCcalc
                
                const command = cmode.getCommand(headerCode);
                if(!command) {
                    //command not explicitly supported, lets just return the data
                    msg.payload = {
                        buffer: Buffer.from(data,"hex")
                    } 
                    node.send(msg);
                } else {
                    msg.cModeResponse.params = [];
                    if(command.response.length === 0) {
                        msg.payload = true
                        node.send(msg);
                    } else {
                        msg.payload = {};
                        for (let index = 0; index < command.response.length; index++) {
                            const param = { ...command.response[index] };
                            const paramNo = index + 1;
                            const paramName = param.name;
                            const paramType = param.type;
                            const paramHint = param.hint;
                            const parser = param.parser || (e => e);
                            const paramValue = parser(data);
                            msg.cModeResponse.params.push({
                                paramNo, paramName, paramType, paramHint, paramValue
                            });
                            msg.payload[paramName] = paramValue;
                            msg.payload.buffer = Buffer.from(data,"hex");
                            node.send(msg);
                        }
                    }
                }

            } catch (error) {
                node.error(error, msg);
            }
        });
    }
    RED.nodes.registerType('C-Mode Response', OmronCModeResponse);
};
