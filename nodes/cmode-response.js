module.exports = function (RED) {
    // eslint-disable-next-line no-debugger
    // debugger
    const C_MODE = require("../lib/_cmode.js");
    const cmodeCache = {
        CSJP: new C_MODE.CModeHelper("CSJP"),
        CV: new C_MODE.CModeHelper("CV"),
        Calpha: new C_MODE.CModeHelper("Calpha"),
    }
    cmodeCache.CS = cmodeCache.CSJP;
    cmodeCache.CJ = cmodeCache.CSJP;
    cmodeCache.CP = cmodeCache.CSJP;
    function OmronCModeResponse(config) {
        RED.nodes.createNode(this, config);
        this.wordNumber = config.wordNumber;
        const node = this;

        node.on('input', function (msg) {
            try {
                const response = (msg.payload || '').trim();//remove CR etc
                const startMarkOK = response.startsWith("@");//get startMark
                const endMarkOK = response.endsWith("*");//get endMark
                const endCode = response.substr(5, 2);
                if(!startMarkOK) {
                    throw new Error("Invalid C-Mode Response. Expected a string beginning with @")
                }
                if(!endMarkOK) {
                    throw new Error("Invalid C-Mode Response. Expected a string ending with *")
                }
                if (!msg.cModeCommand || typeof msg.cModeCommand != "object" || !msg.cModeCommand.plcSeries) {
                    throw new Error("Invalid msg. Expected msg to contain an object named cModeCommand generated by a c-mode command node")
                }
                /** @type {C_MODE.CModeHelper} */
                const cmode = cmodeCache[msg.cModeCommand.plcSeries];
                if(!cmode) {
                    throw new Error("Invalid msg. Expected msg.cModeCommand.plcSeries to contain a valid PLC Series of 'CSJP', 'CV' or 'Calpha'")
                }
                if (endCode !== '00') {
                    const ec = cmode.parseEndCode(endCode);
                    throw new Error(ec);
                }

                //TODO: move the parsing into C_MODE
                const dataStart = 7;
                const totalLength = response.length;
                const dataLength = totalLength - 10;
                const hostNumber = response.substr(1,2);
                const headerCode = response.substr(3,2);
                const data = response.substr(dataStart, dataLength);
                const CRCin = parseInt(response.substr(dataStart+dataLength, 2), 16);
                let CRC = 0;
                for (let ch = 0; ch <= (totalLength - 4); ch++) {
                    CRC = response.charCodeAt(ch) ^ CRC;
                }
                if(CRCin !== CRC) {
                    throw new Error(`Invalid frame check sequence. Received CRC ${CRCin.toString(16)}, expected ${CRC.toString(16)}`)
                }
                if(msg.cModeCommand.hostNumber != hostNumber) {
                    throw new Error(`Unexpected host number. Received ${hostNumber}, expected ${msg.cModeCommand.hostNumber}`)
                }
                if(msg.cModeCommand.headerCode != headerCode) {
                    throw new Error(`Unexpected header code. Received ${headerCode}, expected ${msg.cModeCommand.headerCode}`)
                }
                const command = cmode.getCommand(headerCode);
                msg.cModeResponse = {
                    timestamp: Date.now(),
                    response,
                    hostNumber,
                    headerCode,
                    data,
                    CRC: CRCin,
                    CRCCalc: CRC
                }
                if(!command) {
                    //command not explicitly supported, lets just return the data
                    msg.payload = {
                        buffer: Buffer.from(data,"hex")
                    } 
                    node.send(msg);
                } else {
                    msg.cModeResponse.params = [];
                    msg.payload = {};
                    for (let index = 0; index < command.response.length; index++) {
                        const param = { ...command.response[index] };
                        const paramNo = index + 1;
                        const paramName = param.name;
                        const paramType = param.type;
                        const paramHint = param.hint;
                        const parser = param.parser || (e => e);
                        const paramValue = parser(data);
                        msg.cModeResponse.params.push({
                            paramNo, paramName, paramType, paramHint, paramValue
                        });
                        msg.payload[paramName] = paramValue;
                        msg.payload.buffer = Buffer.from(data,"hex");
                        node.send(msg);
                    }
                }

            } catch (error) {
                node.error(error, msg);
            }
        });
    }
    RED.nodes.registerType('C-Mode Response', OmronCModeResponse);
};
